// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tools.sql

package db

import (
	"context"
	"encoding/json"
)

const getToolByModifiedName = `-- name: GetToolByModifiedName :one
SELECT id, user_id, original_name, modified_name, mcp_hub_server_id, input_schema, annotations, status, created_at, updated_at
FROM mcp_tools WHERE user_id = ? AND modified_name = ? LIMIT 1
`

type GetToolByModifiedNameParams struct {
	UserID       string
	ModifiedName string
}

func (q *Queries) GetToolByModifiedName(ctx context.Context, arg GetToolByModifiedNameParams) (McpTool, error) {
	row := q.db.QueryRowContext(ctx, getToolByModifiedName, arg.UserID, arg.ModifiedName)
	var i McpTool
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.OriginalName,
		&i.ModifiedName,
		&i.McpHubServerID,
		&i.InputSchema,
		&i.Annotations,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listActiveToolsForHub = `-- name: ListActiveToolsForHub :many
SELECT id, user_id, original_name, modified_name, mcp_hub_server_id, input_schema, annotations, status, created_at, updated_at
FROM mcp_tools WHERE mcp_hub_server_id = ? AND status = 'ACTIVE'
`

func (q *Queries) ListActiveToolsForHub(ctx context.Context, mcpHubServerID string) ([]McpTool, error) {
	rows, err := q.db.QueryContext(ctx, listActiveToolsForHub, mcpHubServerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []McpTool
	for rows.Next() {
		var i McpTool
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.OriginalName,
			&i.ModifiedName,
			&i.McpHubServerID,
			&i.InputSchema,
			&i.Annotations,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listToolsForUserFiltered = `-- name: ListToolsForUserFiltered :many
SELECT id, user_id, original_name, modified_name, mcp_hub_server_id, input_schema, annotations, status, created_at, updated_at
FROM mcp_tools
WHERE user_id = ?
  AND (? = '' OR mcp_hub_server_id = ?)
  AND (? = '' OR status = ?)
  AND (? = '' OR (modified_name LIKE CONCAT('%', ?, '%') OR original_name LIKE CONCAT('%', ?, '%')))
ORDER BY modified_name
`

type ListToolsForUserFilteredParams struct {
	UserID         string
	Column2        interface{}
	McpHubServerID string
	Column4        interface{}
	Status         string
	Column6        interface{}
	CONCAT         interface{}
	CONCAT_2       interface{}
}

func (q *Queries) ListToolsForUserFiltered(ctx context.Context, arg ListToolsForUserFilteredParams) ([]McpTool, error) {
	rows, err := q.db.QueryContext(ctx, listToolsForUserFiltered,
		arg.UserID,
		arg.Column2,
		arg.McpHubServerID,
		arg.Column4,
		arg.Status,
		arg.Column6,
		arg.CONCAT,
		arg.CONCAT_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []McpTool
	for rows.Next() {
		var i McpTool
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.OriginalName,
			&i.ModifiedName,
			&i.McpHubServerID,
			&i.InputSchema,
			&i.Annotations,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateToolStatus = `-- name: UpdateToolStatus :exec
UPDATE mcp_tools SET status = ? WHERE id = ?
`

type UpdateToolStatusParams struct {
	Status string
	ID     string
}

func (q *Queries) UpdateToolStatus(ctx context.Context, arg UpdateToolStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateToolStatus, arg.Status, arg.ID)
	return err
}

const upsertTool = `-- name: UpsertTool :exec
INSERT INTO mcp_tools (id, user_id, original_name, modified_name, mcp_hub_server_id, input_schema, annotations, status)
VALUES (?, ?, ?, ?, ?, ?, ?, ?)
ON DUPLICATE KEY UPDATE
  input_schema = VALUES(input_schema),
  annotations = VALUES(annotations),
  status = VALUES(status),
  updated_at = CURRENT_TIMESTAMP
`

type UpsertToolParams struct {
	ID             string
	UserID         string
	OriginalName   string
	ModifiedName   string
	McpHubServerID string
	InputSchema    json.RawMessage
	Annotations    json.RawMessage
	Status         string
}

func (q *Queries) UpsertTool(ctx context.Context, arg UpsertToolParams) error {
	_, err := q.db.ExecContext(ctx, upsertTool,
		arg.ID,
		arg.UserID,
		arg.OriginalName,
		arg.ModifiedName,
		arg.McpHubServerID,
		arg.InputSchema,
		arg.Annotations,
		arg.Status,
	)
	return err
}
